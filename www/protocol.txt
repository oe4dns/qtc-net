Introduction: 

QTC net will be an experimental decentralized message distribution network that is 
designed to have every message public so on operator can forward a message to an 
operator who is not directly connected to the network.

The decentralisation and the designed to be public recuirements are meet by signing each 
message in the network.

The forwarding to an unconnected operator requirement is meet by simply reducuing the 
available message characters and length because a message could be forwarded by CW from 
one operator to another. 

The distribution will be done by rsync via a filesystem structure that is described 
later. rsync provides a good differential syncronisation, and on the other hand a 
file structure leaves space for other transfer protocols. 

------------------------------------------------------------------------
Filesystem Structure: 

	out/       # all the processed good messages ready to got rsynced by others
	call/
		oe1src/ # one directory named like the call / exchanged with -
		.../
			# current operator_file 
			# directory signature file 
			pubkey/
			revoke/
			telegrams/
				sent/ # telegrams sent by this call 
				new/  # telegrams new for this call (no qsp yet) 
				all/  # all telegrams this call ever received by this call
			qsprcvd/    # all qsps this user got
			trust/      # all the trust levels of this user 
		ALIAS -> CALL/ # alias directorys should be symlinked to have easy access on aliased calls.  

	followings/
		FOLLOWINGNAME/      # one directory per following containing a link to the operators homedirectory	
			LINK_TO_CALLDIR/
	in/               # inbound messages are synced into this directory
	bad/              # all messages that have errors to be checked


The Idea is that all incoming messages are placed (and left) in in. After processing they may be found in either out/ or bad/. So another server only needs to rsync from the remotes out/ to the local in/. 

Details are coded in the qtc::processor perl module. 


---------------------------------------------------------------------
Message Format: 

is described in the qtc-message-format.txt document. 

----------------------------------------------------------------------

The filenames are build like this: 

TYPE_CALL_CHECKSUM.qtc

example:

telegram_oe1src_d9382ee0ab8bd0a36ced5c99be10cbca1bedcf84548a00ac5a710dde7e1db956.qtc


-----------------------------------------------------------------------

Details about messages including sanity checks are coded in qtc::msg perl module. 

every message no matter of the type has the following informations: 

- version
- type 
- call ( of the person who publish the message ) 
- signature
- signature_key_id


So far we have the following message types: 

our %msg_types=(
	# this is the message itself with required fields
	telegram=>{
		"telegram_date"=>$valid_date, 
		"from"=>$valid_call, 
		"to"=>$valid_call, 
		"telegram"=>$valid_telegram,
	}, 
	# this is the qsp info where data is stored
	qsp=>{
		"qsp_date"=>$valid_date, 
		"telegram_checksum"=>$valid_checksum,
		"to"=>$valid_call,  #the to field is important for followings 
	}, 
	# aliases and delivery followings 
	operator=>{
		"record_date"=>$valid_date, 
		"set_of_aliases"=>[$valid_call], 
		"set_of_followings"=>[$valid_call],
	}, 
	# keystorage a key has a valid date 
	# you should publish a new key 
	# periodically (once a year)
	pubkey=>{
		"key_date"=>$valid_date,  
		"key_type"=>$valid_rsa_or_dsa,  
		"key_id"=>$valid_checksum,  
		"key"=>$valid_hex,
	},
	# revokes are designed to be self signed 
	# this means they are valid even without a 
	# korresponding pubkey
	revoke=>{
		"key_type"=>$valid_rsa_or_dsa,  
		"key_id"=>$valid_checksum,  
		"key"=>$valid_hex,
	},
	# trust and untrust users 
	trust=>{
		"trust_date"=>$valid_date,
		"trustlevel"=>$valid_trustlevel,
		"to"=>$valid_call, # it is easier to store the call than to read every key for its ID
		"set_of_key_ids"=>[$valid_checksum],
	},
);


